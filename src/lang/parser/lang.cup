package lang.parser;
import java_cup.runtime.*;
import java.util.*;
import java.io.*;
import lang.nodes.*;
import lang.nodes.expr.*;


parser code {:
    public void syntax_error(Symbol s){
        System.out.println("Compiler has detected a syntax error at line " + (s.left + 1) 
            + " column " + (s.right + 1) );
    }
    public Parser(Lexer lex, ComplexSymbolFactory sf) {
        super(lex,sf);
    }

:};

terminal ID, INT, FLOAT, CHAR, VOID, BOOL;
terminal INTEGER_LITERAL, FLOAT_LITERAL, CHAR_LITERAL, STRING_LITERAL, TYPE_NAME;
terminal LPAREN, RPAREN, LBRACE, RBRACE, LBRACKET, RBRACKET, SEMI, COMMA, COLON, DOUBLECOLON, ATTR;
terminal PLUS, MINUS, TIMES, DIVIDE, MOD;
terminal LESS_THAN, EQUALS, NOT_EQUALS;
terminal LOGICAL_AND, LOGICAL_NOT, TRUE, FALSE, NULL, NEW;
terminal IF, ELSE, ITERATE, READ, PRINT, RETURN;
terminal MINUS_UNARY, DOT;
terminal DATA;

// Declaração dos não-terminais
nonterminal prog, def_list, def, data, decl, func, params, type, btype, cmd, exp;
nonterminal lvalue, exps, decl_list, opt_params, opt_type_list, cmd_list, type_list, exp_list, opt_exps; 
nonterminal opt_lvalue_list, lvalue_list, new_dimensions, dimension_list,more_dimensions;

precedence left RBRACKET;
precedence left DOT;
precedence left RPAREN;

precedence right LOGICAL_NOT;
precedence right MINUS_UNARY;

precedence left TIMES, DIVIDE, MOD;
precedence left PLUS, MINUS, ATTR;

precedence nonassoc LESS_THAN;
precedence nonassoc EQUALS, NOT_EQUALS;
precedence nonassoc LOGICAL_NOT;
precedence nonassoc LOGICAL_AND;


start with prog;

prog ::= def_list;

def_list ::= def
           | def_list def
           ;

def ::= data
      | func
      ;

data ::= DATA ID LBRACE decl_list RBRACE;

decl_list ::= decl
            | decl_list decl
            ;

decl ::= ID DOUBLECOLON type SEMI;

func ::= ID LPAREN opt_params RPAREN opt_type_list LBRACE cmd_list RBRACE;

opt_params ::= 
             | params 
             ;

params ::= ID DOUBLECOLON type 
         | params COMMA ID DOUBLECOLON type
         ;

opt_type_list ::=
              | COLON type_list
              ;

type_list ::= type
            | type_list COMMA type
            ;

type ::= btype dimension_list;


btype ::= INT
        | CHAR
        | BOOL
        | FLOAT
        | VOID
        | TYPE_NAME
        ;

cmd_list ::= 
           | cmd_list cmd
           ;

cmd ::= LBRACE cmd_list RBRACE
      | IF LPAREN exp RPAREN cmd
      | IF LPAREN exp RPAREN cmd ELSE cmd
      | ITERATE LPAREN exp RPAREN cmd
      | READ lvalue SEMI
      | PRINT exp SEMI
      | RETURN exp_list SEMI
      | lvalue ATTR exp SEMI
      | ID ATTR exp SEMI
      | ID LPAREN opt_exps RPAREN opt_lvalue_list SEMI
      ;

opt_exps ::= 
           | exps
           ;

opt_lvalue_list ::= 
                  | LBRACE lvalue_list RBRACE
                  ;

lvalue_list ::= lvalue
              | lvalue_list COMMA lvalue
              ;

exp_list ::= exp
           | exp_list COMMA exp
           ;

exp ::= exp LOGICAL_AND exp
      | exp LESS_THAN exp
      | exp EQUALS exp
      | exp NOT_EQUALS exp
      | exp PLUS exp
      | exp MINUS exp
      | exp TIMES exp
      | exp DIVIDE exp
      | exp MOD exp
      | LOGICAL_NOT exp
      | MINUS_UNARY exp
      | TRUE
      | FALSE
      | NULL
      | INTEGER_LITERAL
      | FLOAT_LITERAL
      | CHAR_LITERAL
      | STRING_LITERAL
      | lvalue
      | LPAREN exp RPAREN
      | NEW type new_dimensions
      | ID LPAREN opt_exps RPAREN LBRACKET exp RBRACKET
      ;


dimension_list ::=
                | dimension_list LBRACKET RBRACKET
                ;

new_dimensions ::= LBRACKET exp RBRACKET more_dimensions;

more_dimensions ::= 
                  | more_dimensions LBRACKET exp RBRACKET
                  ;


lvalue ::= ID
         | lvalue LBRACKET exp RBRACKET
         | lvalue DOT ID
         ;

exps ::= exp
       | exps COMMA exp
       ;