%package "lang.parser";

%import "lang.nodes.*";
%import "lang.nodes.expr.*";

%class "LangParserB";

%embed{:  

:};

%init {:  :} ;

%terminals  INT, CHAR, BOOL, FLOAT,VOID;
%terminals  ID, INTEGER_LITERAL, FLOAT_LITERAL, CHAR_LITERAL, STRING_LITERAL, TYPE_NAME;
%terminals  TRUE, FALSE, NULL;
%terminals  LBRACE, RBRACE, LPAREN, RPAREN, LBRACKET, RBRACKET; 
%terminals  DOUBLECOLON, SEMICOLON, COLON, COMMA,DOT;
%terminals  PLUS, MINUS, TIMES, DIVIDE, MOD, MINUS_UNARY;
%terminals  LOGICAL_NOT,LOGICAL_AND,LOGICAL_OR; 
%terminals  EQUALS, NOT_EQUALS, LESS_THAN, GREATER_THAN, LESS_OR_EQUAL, GREATER_OR_EQUAL, ATTR;
%terminals  NEW, DATA, IF, ELSE, WHILE, READ, PRINT, RETURN; 

%left RBRACKET;
%left RPAREN;
%left DOT;

%right LOGICAL_NOT;
%right MINUS_UNARY;

%left TIMES, DIVIDE, MOD;
%left PLUS, MINUS, ATTR;


%typeof INTEGER_LITERAL = "Integer";
%typeof FLOAT_LITERAL = "Double";
%typeof CHAR_LITERAL = "Char";
%typeof STRING_LITERAL = "String";
%typeof ID = "String";
%typeof def = "CFuncDef";
%typeof exp = "Exp";
%typeof params = "CVarDec";

%goal Prog;

Prog = def.s+                                  {:  return new CProg(s);         :}
    ;

def        = data | func;
data       = DATA TYPE_NAME LBRACE decl* RBRACE ;

decl       =  ID DOUBLECOLON type SEMICOLON;

func       =  ID.v LPAREN params.d? RPAREN COLON type.t? LBRACE cmd.b* RBRACE {: return new CFuncDef(v,d,t,b);  :}
            ;

params     =  ID DOUBLECOLON type LPAREN COMMA  ID DOUBLECOLON type RPAREN*;

type       = type LBRACKET RBRACKET
            | btype;

btype      = INT
            | CHAR
            | BOOL
            | FLOAT
            | VOID
            | TYPE_NAME;

cmd = block
   | ifCmd
   | whileCmd
   | readCmd
   | printCmd
   | returnCmd
   | assignCmd
   | funcCallCmd
   ;

block = LBRACE cmd* RBRACE;
ifCmd = IF LPAREN exp RPAREN cmd ELSE? cmd;
whileCmd = WHILE LPAREN exp RPAREN cmd;
readCmd = READ lvalue SEMICOLON;
printCmd = PRINT exp SEMICOLON;
returnCmd = RETURN exp COMMA exp* SEMICOLON;
assignCmd = lvalue ATTR exps? SEMICOLON;
funcCallCmd = ID LPAREN exps? RPAREN LESS_THAN lvalue COMMA lvalue* GREATER_THAN? SEMICOLON;


exp        = exp LOGICAL_AND exp
            | exp LOGICAL_OR exp
            | rexp;

rexp       = aexp.a LESS_THAN aexp.b
            | rexp EQUALS aexp
            | rexp NOT_EQUALS aexp
            | rexp GREATER_THAN aexp
            | rexp GREATER_OR_EQUAL aexp
            | rexp LESS_OR_EQUAL aexp
            | aexp;

aexp       = aexp PLUS mexp
            | aexp MINUS mexp
            | mexp;

mexp       = mexp TIMES sexp
            | mexp DIVIDE sexp
            | mexp MOD sexp
            | sexp;

sexp       =  LOGICAL_NOT sexp
            | MINUS_UNARY sexp
            | TRUE
            | FALSE
            | NULL
            | INTEGER_LITERAL
            | FLOAT_LITERAL
            | CHAR_LITERAL
            | STRING_LITERAL
            | pexp;

pexp       = lvalue
            | LPAREN exp RPAREN
            | NEW type LBRACKET LPAREN LBRACKET exp RBRACKET RPAREN? 
            | ID LPAREN exps? RBRACKET;

lvalue     =  ID
            | lvalue LBRACKET exp RBRACKET
            | lvalue DOT ID;

exps       = exp LPAREN COMMA exp RPAREN*;