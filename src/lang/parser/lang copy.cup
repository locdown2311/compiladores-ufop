package lang.parser;
import java_cup.runtime.*;
import java.util.*;
import java.io.*;
import lang.nodes.*;
import lang.nodes.expr.*;


parser code {:
    public void syntax_error(Symbol s){
        System.out.println("Compiler has detected a syntax error at line " + (s.left + 1) 
            + " column " + (s.right + 1) );
    }
    public Parser(Lexer lex, ComplexSymbolFactory sf) {
        super(lex,sf);
    }

:};

/* Terminais */
terminal INT, CHAR, BOOL, FLOAT,VOID;
terminal ID, INTEGER_LITERAL, FLOAT_LITERAL, CHAR_LITERAL, STRING_LITERAL, TYPE_NAME;
terminal TRUE, FALSE, NULL;
terminal LBRACE, RBRACE, LPAREN, RPAREN, LBRACKET, RBRACKET; 
terminal DOUBLECOLON, SEMICOLON, COLON, COMMA,DOT;
terminal PLUS, MINUS, TIMES, DIVIDE, MOD, MINUS_UNARY;
terminal LOGICAL_NOT,LOGICAL_AND,LOGICAL_OR; 
terminal EQUALS, NOT_EQUALS, LESS_THAN, GREATER_THAN, LESS_OR_EQUAL, GREATER_OR_EQUAL, ATTR;
terminal NEW, DATA, IF, ELSE, WHILE, READ, PRINT, RETURN; 
/* NÃ£o-terminais */
non terminal Prog, Def, DataDecl, Decl, Fun, Params, Type, Btype, Cmd, Exp, Lvalue, Exps, Defs, Decls, OptParams, OptReturnTypes, Cmds, OtherParams, MoreReturnTypes, TypeDim, ReturnExps, OptExps, OptLvalues, FurtherExps, MoreLvalues;
non terminal OtherExps;

precedence left RBRACKET;
precedence left DOT;
precedence left RPAREN;

precedence right LOGICAL_NOT;
precedence right MINUS_UNARY;

precedence left TIMES, DIVIDE, MOD;
precedence left PLUS, MINUS, ATTR;

precedence nonassoc LESS_THAN;
precedence nonassoc EQUALS, NOT_EQUALS;
precedence nonassoc LOGICAL_NOT;
precedence nonassoc LOGICAL_AND;

start with Prog;

Prog ::= def ;

def ::= DATA ID LBRACE RBRACE 
        | func;

data ::= DATA ID LBRACE RBRACE;

decl ::= ID DOUBLECOLON type SEMICOLON;

func ::= ID LPAREN LBRACKET params RBRACKET RPAREN LBRACKET COLON type LPAREN COMMA type RPAREN* RBRACKET LBRACE cmd RBRACE;

params ::= ID DOUBLECOLON type LBRACE COMMA ID DOUBLECOLON type RBRACE;

type ::= type LBRACKET RBRACKET
       | btype;


btype ::= INT
       | CHAR
       | BOOL
       | FLOAT
       | TYPE_NAME;
cmd ::= LBRACE LBRACE cmd RBRACE  RBRACE
      | IF LPAREN exp RPAREN cmd
      | IF LPAREN exp RPAREN cmd ELSE cmd
      | WHILE LPAREN exp RPAREN cmd
      | READ lvalue SEMICOLON
      | PRINT exp SEMICOLON
      | RETURN exp LBRACE COMMA exp RBRACE  SEMICOLON
      | lvalue ATTR exp SEMICOLON
      | ID ATTR exp SEMICOLON
      | ID LPAREN LBRACKET exps RBRACKET RPAREN LBRACKET LESS_THAN lvalue LBRACE COMMA lvalue RBRACE RBRACKET SEMICOLON;
exp ::= exp LOGICAL_AND exp
      | exp LESS_THAN exp
      | exp EQUALS exp
      | exp NOT_EQUALS exp
      | exp PLUS exp
      | exp MINUS exp
      | exp TIMES exp
      | exp DIVIDE exp
      | exp MOD exp
      | MINUS_UNARY exp
      | TRUE
      | FALSE
      | NULL
      | INTEGER_LITERAL
      | FLOAT_LITERAL
      | CHAR_LITERAL
      | lvalue
      | LPAREN exp RPAREN
      | NEW type LBRACE LBRACKET exp RBRACKET RBRACE 
      | ID LPAREN LBRACKET exps RBRACKET RPAREN LBRACKET exp RBRACKET;
lvalue ::= ID
        | lvalue LBRACKET exp RBRACKET
        | lvalue DOT ID;
exps ::= exp LBRACE COMMA exp RBRACE ;